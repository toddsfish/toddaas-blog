<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 2 | toddaas blog</title><meta name=keywords content="aws,automation,ec2 autoscaling,ec2,autoscaling,lambda function,eventbridge,serverless,lambda,cdk,gateway load balancer,firewalls,cloud development kit,autoscaling warm pools,warm pool,cdk construct,construct hub"><meta name=description content="Overdue for Part 2 so thought I&rsquo;d include some of my learnings along the way&mldr;
Why Warm Pools again? Taking a step back to networking for a brief second and Warm pools from Part 1. Warm Pools are very useful for scaling network appliances for example a set of firewall appliances in an Autoscaling Group behind a Gateway Load Balancer (GWLB). This is simply because notoriously network appliances often take a long time to boot getting all their bootstrapping and inspection, IPS/IDS jazz together."><meta name=author content="Todd"><link rel=canonical href=https://blog.toddaas.com/posts/ec2_warm_pools_are_useful_part_2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.toddaas.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.toddaas.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.toddaas.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.toddaas.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.toddaas.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-K29FPB2EME"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K29FPB2EME",{anonymize_ip:!1})}</script><meta property="og:title" content="EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 2"><meta property="og:description" content="Overdue for Part 2 so thought I&rsquo;d include some of my learnings along the way&mldr;
Why Warm Pools again? Taking a step back to networking for a brief second and Warm pools from Part 1. Warm Pools are very useful for scaling network appliances for example a set of firewall appliances in an Autoscaling Group behind a Gateway Load Balancer (GWLB). This is simply because notoriously network appliances often take a long time to boot getting all their bootstrapping and inspection, IPS/IDS jazz together."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.toddaas.com/posts/ec2_warm_pools_are_useful_part_2/"><meta property="og:image" content="https://blog.toddaas.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-04T05:10:21+10:00"><meta property="article:modified_time" content="2024-04-04T05:10:21+10:00"><meta property="og:site_name" content="toddaas"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.toddaas.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 2"><meta name=twitter:description content="Overdue for Part 2 so thought I&rsquo;d include some of my learnings along the way&mldr;
Why Warm Pools again? Taking a step back to networking for a brief second and Warm pools from Part 1. Warm Pools are very useful for scaling network appliances for example a set of firewall appliances in an Autoscaling Group behind a Gateway Load Balancer (GWLB). This is simply because notoriously network appliances often take a long time to boot getting all their bootstrapping and inspection, IPS/IDS jazz together."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.toddaas.com/posts/"},{"@type":"ListItem","position":2,"name":"EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 2","item":"https://blog.toddaas.com/posts/ec2_warm_pools_are_useful_part_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 2","name":"EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 2","description":"Overdue for Part 2 so thought I\u0026rsquo;d include some of my learnings along the way\u0026hellip;\nWhy Warm Pools again? Taking a step back to networking for a brief second and Warm pools from Part 1. Warm Pools are very useful for scaling network appliances for example a set of firewall appliances in an Autoscaling Group behind a Gateway Load Balancer (GWLB). This is simply because notoriously network appliances often take a long time to boot getting all their bootstrapping and inspection, IPS/IDS jazz together.","keywords":["aws","automation","ec2 autoscaling","ec2","autoscaling","lambda function","eventbridge","serverless","lambda","cdk","gateway load balancer","firewalls","cloud development kit","autoscaling warm pools","warm pool","cdk construct","construct hub"],"articleBody":"Overdue for Part 2 so thought I’d include some of my learnings along the way…\nWhy Warm Pools again? Taking a step back to networking for a brief second and Warm pools from Part 1. Warm Pools are very useful for scaling network appliances for example a set of firewall appliances in an Autoscaling Group behind a Gateway Load Balancer (GWLB). This is simply because notoriously network appliances often take a long time to boot getting all their bootstrapping and inspection, IPS/IDS jazz together. Therefore by using Warmpools a network appliance can be quickly placed in service in the Autoscaling Group, without the necessity of overprovisioning the Autoscaling Group with running instances incurring unnecessary costs. With that said if your using Warmpools alongside Lifecycle Hooks you need to take into account the additional overheads of automation to move instances from the Warmpool to the Autoscaling Group. This post covers the CDK Construct I wrote for Warmpools to extend the existing functionality of the default CDK WarmPool class to support this requried automation for use with future Autoscaling Groups backed by Firewall appliances or EC2 instances using Lifecycle Hooks. CDK constructs allow you to abstract, reuse, repeat.\nCDK Constructs I’ve been using the AWS Cloud Development Kit (CDK) for a few years now since version 1 (now version 2) predominately for proof of concepts, testing AWS services and as part of automating my troubleshooting workflow in replicating customer environments. Mainly the constructs I’ve been using are the AWS service constructs. That said as I’ve got into using the CDK more and more. I’ve found myself using other Construct libraries which speed up implementation of existing best practice patterns practice patterns or just mashing together AWS service constructs with abstractions though Open Source constructs available via Construct Hub. CDKs ability to share abstactions of cloud infrastructure underpinned by around a modern programming language is what makes it great. AWS has also opensourced the Construct Hub https://github.com/cdklabs/construct-hub itself. for the use case of a private construct library within an organisation to share reuseable IaC constructs and patterns.\nNow onto the CDK constructs, when it comes to the AWS service Level 2 (L2) constructs whilst they are supposed to operate a higher level of abstraction i.e. not require initialisation of the same properties of a CFN resource. L2 constucts do not cater to all usaage scenario. This means at times they often represent resources similar to the lowest level abstraction of Level (L1) constructs basically the raw CFN resources and resource properties. This is where the composition over inheritance principle with CDK allows you to extend an existing CDK constructs functionality to include other constructs and cater to custom use cases. For example in automating Autoscaling groups using Warm pools to move instances from the Warm pool into service automatically, something which the default L2 CDK WarmPool class does not do by default.\nProjen What I discovered along the way when wanting to share my construct with the CDK community. Is that there is some barrier to entry (contribute) when it comes to meeting the requirements to have a a CDK Construct in Construct Hub. To add it was a manual process to release changes or updates to my construct whilst meeting these requirements and then push these changes to NPM which are synced to Construct Hub. This is where a tool called Projen https://projen.io/ helped alot. Projen does a lot of the heavy lifting required in terms of scaffolding a consumable CDK construct or any other supported project. This includes generating CI/CD pipelines based around Conventional Commits https://www.conventionalcommits.org/en/v1.0.0/ in the form of Github Actions workflows. For example a release workflow for validating a CDK construct and releasing the construct to the NPM public repositories conforming to Construct Hub (https://constructs.dev/contribute) requirements. Projen also has a workflow for keeping any code dependancies nicely updated automatically through PRs on the repository.\nMy Warm Pool CDK Construct So how does my Warm pools construct work what does it do? Essentially the the construct extends CDK WarmPool class with Lambda function thats triggered through a Cloudwatch EventBridge Rule when an instances moves out of a Warm Pool. EC2 Autoscaling like most AWS services publishes its events to Cloudwatch EventBridge. As such its simple to create an EventBridge rule that filters for Warm Pool origin related events based on the autoscaling group then trigger the Lambda calling complete-lifecycle-action and placing the instance in service.\nA CDK App Example Heres a simple CDK app using the my Warm Pool Contruct. https://github.com/toddsfish/warmpools-test You can also use this example CDK app if you just want to play around with the behaviour of Autoscaling Warm Pools in general.\n","wordCount":"775","inLanguage":"en","datePublished":"2024-04-04T05:10:21+10:00","dateModified":"2024-04-04T05:10:21+10:00","author":{"@type":"Person","name":"Todd"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.toddaas.com/posts/ec2_warm_pools_are_useful_part_2/"},"publisher":{"@type":"Organization","name":"toddaas blog","logo":{"@type":"ImageObject","url":"https://blog.toddaas.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.toddaas.com/ accesskey=h title="  (Alt + H)"></a><div class=logo-switches></div></div><ul id=menu><li><a href=https://blog.toddaas.com/ title=home><span>home</span></a></li><li><a href=https://blog.toddaas.com/posts/ title=posts><span>posts</span></a></li><li><a href=https://blog.toddaas.com/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 2</h1><div class=post-meta><span title='2024-04-04 05:10:21 +1000 +1000'>April 4, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Todd</div></header><div class=post-content><p>Overdue for Part 2 so thought I&rsquo;d include some of my learnings along the way&mldr;</p><h2 id=why-warm-pools-again>Why Warm Pools again?<a hidden class=anchor aria-hidden=true href=#why-warm-pools-again>#</a></h2><p>Taking a step back to networking for a brief second and Warm pools from <a href=https://blog.toddaas.com/posts/ec2_warm_pools_are_useful_part_1/>Part 1</a>. Warm Pools are very useful for scaling network appliances for example a set of firewall appliances in an Autoscaling Group behind a Gateway Load Balancer (GWLB). This is simply because notoriously network appliances often take a long time to boot getting all their bootstrapping and inspection, IPS/IDS jazz together. Therefore by using Warmpools a network appliance can be quickly placed in service in the Autoscaling Group, without the necessity of overprovisioning the Autoscaling Group with running instances incurring unnecessary costs. With that said if your using Warmpools alongside Lifecycle Hooks you need to take into account the additional overheads of automation to move instances from the Warmpool to the Autoscaling Group. This post covers the CDK Construct I wrote for Warmpools to extend the existing functionality of the default <a href=https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_autoscaling.WarmPool.html>CDK WarmPool class</a> to support this requried automation for use with future Autoscaling Groups backed by Firewall appliances or EC2 instances using Lifecycle Hooks. CDK constructs allow you to abstract, reuse, repeat.</p><h2 id=cdk-constructs>CDK Constructs<a hidden class=anchor aria-hidden=true href=#cdk-constructs>#</a></h2><p>I&rsquo;ve been using the AWS Cloud Development Kit (CDK) for a few years now since version 1 (now version 2) predominately for proof of concepts, testing AWS services and as part of automating my troubleshooting workflow in replicating customer environments. Mainly the constructs I&rsquo;ve been using are the AWS service constructs. That said as I&rsquo;ve got into using the CDK more and more. I&rsquo;ve found myself using other Construct libraries which speed up implementation of existing best practice patterns <a href=https://docs.aws.amazon.com/solutions/latest/constructs/welcome.html>practice patterns</a> or just mashing together AWS service constructs with abstractions though Open Source constructs available via <a href=https://constructs.dev/>Construct Hub</a>. CDKs ability to share abstactions of cloud infrastructure underpinned by around a modern programming language is what makes it great. AWS has also opensourced the Construct Hub <a href=https://github.com/cdklabs/construct-hub>https://github.com/cdklabs/construct-hub</a> itself. for the use case of a private construct library within an organisation to share reuseable IaC constructs and patterns.</p><p>Now onto the CDK constructs, when it comes to the AWS service Level 2 (L2) constructs whilst they are supposed to operate a higher level of abstraction i.e. not require initialisation of the same properties of a CFN resource. L2 constucts do not cater to all usaage scenario. This means at times they often represent resources similar to the lowest level abstraction of Level (L1) constructs basically the raw CFN resources and resource properties. This is where the composition over inheritance principle with CDK allows you to extend an existing CDK constructs functionality to include other constructs and cater to custom use cases. For example in automating Autoscaling groups using Warm pools to move instances from the Warm pool into service automatically, something which the default L2 <a href=https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_autoscaling.WarmPool.html>CDK WarmPool class</a> does not do by default.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/pnFisVo40nk style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div><h2 id=projen>Projen<a hidden class=anchor aria-hidden=true href=#projen>#</a></h2><p>What I discovered along the way when wanting to share my construct with the CDK community. Is that there is some barrier to entry (contribute) when it comes to meeting the requirements to have a a CDK Construct in Construct Hub. To add it was a manual process to release changes or updates to my construct whilst meeting these requirements and then push these changes to NPM which are synced to Construct Hub. This is where a tool called Projen <a href=https://projen.io/>https://projen.io/</a> helped alot. Projen does a lot of the heavy lifting required in terms of scaffolding a consumable CDK construct or any other supported project. This includes generating CI/CD pipelines based around Conventional Commits <a href=https://www.conventionalcommits.org/en/v1.0.0/>https://www.conventionalcommits.org/en/v1.0.0/</a> in the form of Github Actions workflows. For example a release workflow for validating a CDK construct and releasing the construct to the NPM public repositories conforming to Construct Hub (<a href=https://constructs.dev/contribute>https://constructs.dev/contribute</a>) requirements. Projen also has a workflow for keeping any code dependancies nicely updated automatically through PRs on the repository.</p><h2 id=my-warm-pool-cdk-construct>My Warm Pool CDK Construct<a hidden class=anchor aria-hidden=true href=#my-warm-pool-cdk-construct>#</a></h2><p>So how does my Warm pools construct work what does it do? Essentially the the construct extends <a href=https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_autoscaling.WarmPool.html>CDK WarmPool class</a> with Lambda function thats triggered through a Cloudwatch EventBridge Rule when an instances moves out of a Warm Pool. EC2 Autoscaling like most AWS services publishes its events to Cloudwatch EventBridge. As such its simple to create an EventBridge rule that filters for Warm Pool origin related events based on the autoscaling group then trigger the Lambda calling complete-lifecycle-action and placing the instance in service.</p><p><a href=https://constructs.dev/packages/@pandanus-cloud/cdk-autoscaling-warmpool><img loading=lazy src="https://constructs.dev/badge?package=%40pandanus-cloud%2Fcdk-autoscaling-warmpool" alt="View on Construct Hub"></a></p><h2 id=a-cdk-app-example>A CDK App Example<a hidden class=anchor aria-hidden=true href=#a-cdk-app-example>#</a></h2><p>Heres a simple CDK app using the my Warm Pool Contruct.
<a href=https://github.com/toddsfish/warmpools-test>https://github.com/toddsfish/warmpools-test</a>
You can also use this example CDK app if you just want to play around with the behaviour of Autoscaling Warm Pools in general.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.toddaas.com/tags/aws/>aws</a></li><li><a href=https://blog.toddaas.com/tags/automation/>automation</a></li><li><a href=https://blog.toddaas.com/tags/ec2-autoscaling/>ec2 autoscaling</a></li><li><a href=https://blog.toddaas.com/tags/ec2/>ec2</a></li><li><a href=https://blog.toddaas.com/tags/autoscaling/>autoscaling</a></li><li><a href=https://blog.toddaas.com/tags/lambda-function/>lambda function</a></li><li><a href=https://blog.toddaas.com/tags/eventbridge/>eventbridge</a></li><li><a href=https://blog.toddaas.com/tags/serverless/>serverless</a></li><li><a href=https://blog.toddaas.com/tags/lambda/>lambda</a></li><li><a href=https://blog.toddaas.com/tags/cdk/>cdk</a></li><li><a href=https://blog.toddaas.com/tags/gateway-load-balancer/>gateway load balancer</a></li><li><a href=https://blog.toddaas.com/tags/firewalls/>firewalls</a></li><li><a href=https://blog.toddaas.com/tags/cloud-development-kit/>cloud development kit</a></li><li><a href=https://blog.toddaas.com/tags/autoscaling-warm-pools/>autoscaling warm pools</a></li><li><a href=https://blog.toddaas.com/tags/warm-pool/>warm pool</a></li><li><a href=https://blog.toddaas.com/tags/cdk-construct/>cdk construct</a></li><li><a href=https://blog.toddaas.com/tags/construct-hub/>construct hub</a></li></ul><nav class=paginav><a class=next href=https://blog.toddaas.com/posts/ec2_warm_pools_are_useful_part_1/><span class=title>Next »</span><br><span>EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 1</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2024 <a href=https://blog.toddaas.com/>toddaas blog</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>