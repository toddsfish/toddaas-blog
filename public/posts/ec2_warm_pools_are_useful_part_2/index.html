<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 2 | toddaas blog</title>
<meta name=keywords content="aws,automation,ec2 autoscaling,ec2,autoscaling,lambda function,eventbridge,serverless,lambda,cdk,gateway load balancer,firewalls,cloud development kit,autoscaling warm pools,warmpools,cdk construct,construct hub"><meta name=description content="Overdue for Part 2 so thought I&rsquo;d include some of my learnings along the way&mldr;
Why Warm Pools again? Taking a step back to networking for a brief second and Warm pools from Part 1. Warm Pools are very useful for scaling network appliances, for example, a set of firewall appliances in an Autoscaling Group behind a Gateway Load Balancer (GWLB). This is simply because notoriously network appliances often take a long time to boot getting all their bootstrapping and inspection, IPS/IDS jazz together."><meta name=author content="Todd"><link rel=canonical href=https://blog.toddaas.com/posts/ec2_warm_pools_are_useful_part_2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.toddaas.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.toddaas.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.toddaas.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.toddaas.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.toddaas.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.toddaas.com/posts/ec2_warm_pools_are_useful_part_2/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-K29FPB2EME"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K29FPB2EME",{anonymize_ip:!1})}</script><meta property="og:title" content="EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 2"><meta property="og:description" content="Overdue for Part 2 so thought I&rsquo;d include some of my learnings along the way&mldr;
Why Warm Pools again? Taking a step back to networking for a brief second and Warm pools from Part 1. Warm Pools are very useful for scaling network appliances, for example, a set of firewall appliances in an Autoscaling Group behind a Gateway Load Balancer (GWLB). This is simply because notoriously network appliances often take a long time to boot getting all their bootstrapping and inspection, IPS/IDS jazz together."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.toddaas.com/posts/ec2_warm_pools_are_useful_part_2/"><meta property="og:image" content="https://blog.toddaas.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-04T05:10:21+10:00"><meta property="article:modified_time" content="2024-04-04T05:10:21+10:00"><meta property="og:site_name" content="toddaas"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.toddaas.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 2"><meta name=twitter:description content="Overdue for Part 2 so thought I&rsquo;d include some of my learnings along the way&mldr;
Why Warm Pools again? Taking a step back to networking for a brief second and Warm pools from Part 1. Warm Pools are very useful for scaling network appliances, for example, a set of firewall appliances in an Autoscaling Group behind a Gateway Load Balancer (GWLB). This is simply because notoriously network appliances often take a long time to boot getting all their bootstrapping and inspection, IPS/IDS jazz together."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.toddaas.com/posts/"},{"@type":"ListItem","position":2,"name":"EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 2","item":"https://blog.toddaas.com/posts/ec2_warm_pools_are_useful_part_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 2","name":"EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 2","description":"Overdue for Part 2 so thought I\u0026rsquo;d include some of my learnings along the way\u0026hellip;\nWhy Warm Pools again? Taking a step back to networking for a brief second and Warm pools from Part 1. Warm Pools are very useful for scaling network appliances, for example, a set of firewall appliances in an Autoscaling Group behind a Gateway Load Balancer (GWLB). This is simply because notoriously network appliances often take a long time to boot getting all their bootstrapping and inspection, IPS/IDS jazz together.","keywords":["aws","automation","ec2 autoscaling","ec2","autoscaling","lambda function","eventbridge","serverless","lambda","cdk","gateway load balancer","firewalls","cloud development kit","autoscaling warm pools","warmpools","cdk construct","construct hub"],"articleBody":"Overdue for Part 2 so thought I’d include some of my learnings along the way…\nWhy Warm Pools again? Taking a step back to networking for a brief second and Warm pools from Part 1. Warm Pools are very useful for scaling network appliances, for example, a set of firewall appliances in an Autoscaling Group behind a Gateway Load Balancer (GWLB). This is simply because notoriously network appliances often take a long time to boot getting all their bootstrapping and inspection, IPS/IDS jazz together. Therefore, by using Warm pools, a network appliance can be quickly placed in service in the Autoscaling Group, without the necessity of overprovisioning the Autoscaling Group with running instances incurring unnecessary costs. With that said, if you’re using Warm pools alongside Lifecycle Hooks you need to take into account the additional overheads of automation to move instances from the Warm pool to the Autoscaling Group. This post covers the CDK Construct I wrote for Warm pools to extend the existing functionality of the default CDK WarmPool class to support this required automation for use with future Autoscaling Groups backed by Firewall appliances or EC2 instances using Lifecycle Hooks. CDK constructs allow you to abstract, reuse, repeat.\nCDK Constructs I’ve been using the AWS Cloud Development Kit (CDK) for a few years now since version 1 (now version 2), predominantly for proof of concepts, testing AWS services, and as part of automating my troubleshooting workflow in replicating customer environments. Mainly the constructs I’ve been using are the AWS service constructs. That said, as I’ve gotten into using the CDK more and more, I’ve found myself using other Construct libraries which speed up the implementation of existing best practice patterns practice patterns or just mashing together AWS service constructs with abstractions though Open Source constructs available via Construct Hub. CDK’s ability to share abstractions of cloud infrastructure underpinned by a modern programming language is what makes it great. AWS has also open-sourced the Construct Hub here itself, for the use case of a private construct library within an organization to share reusable IaC constructs and patterns.\nNow onto the CDK constructs, when it comes to the AWS service Level 2 (L2) constructs whilst they are supposed to operate at a higher level of abstraction, i.e., not require initialization of the same properties of a CFN resource. L2 constructs do not cater to all usage scenarios. This means that at times they often represent resources similar to the lowest level abstraction of Level (L1) constructs, basically the raw CFN resources and resource properties. This is where the composition over inheritance principle with CDK allows you to extend an existing CDK construct’s functionality to include other constructs and cater to custom use cases. For example, in automating Autoscaling groups using Warm pools to move instances from the Warm pool into service automatically, something which the default L2 CDK WarmPool class does not do by default.\nProjen What I discovered along the way when wanting to share my construct with the CDK community, is that there is some barrier to entry (contribute) when it comes to meeting the requirements to have a CDK Construct in Construct Hub. To add, it was a manual process to release changes or updates to my construct whilst meeting these requirements and then push these changes to NPM, which are synced to Construct Hub. This is where a tool called Projen here helped a lot. Projen does a lot of the heavy lifting required in terms of scaffolding a consumable CDK construct or any other supported project. This includes generating CI/CD pipelines based around Conventional Commits here in the form of Github Actions workflows. For example, a release workflow for validating a CDK construct and releasing the construct to the NPM public repositories, conforming to Construct Hub requirements. Projen also has a workflow for keeping any code dependencies nicely updated automatically through PRs on the repository.\nMy Warm Pool CDK Construct So how does my Warm pools construct work, what does it do? Essentially, the construct extends CDK WarmPool class with a Lambda function that’s triggered through a CloudWatch EventBridge Rule when an instance moves out of a Warm Pool. EC2 Autoscaling, like most AWS services, publishes its events to CloudWatch EventBridge. As such, it’s simple to create an EventBridge rule that filters for Warm Pool origin-related events based on the autoscaling group, then trigger the Lambda, calling complete-lifecycle-action and placing the instance in service.\nA CDK App Example Here’s a simple CDK app using the my Warm Pool Construct https://github.com/toddsfish/warmpools-test. You can also use this example CDK app if you just want to play around with the behavior of Autoscaling Warm Pools in general.\n","wordCount":"779","inLanguage":"en","image":"https://blog.toddaas.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-04-04T05:10:21+10:00","dateModified":"2024-04-04T05:10:21+10:00","author":{"@type":"Person","name":"Todd"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.toddaas.com/posts/ec2_warm_pools_are_useful_part_2/"},"publisher":{"@type":"Organization","name":"toddaas blog","logo":{"@type":"ImageObject","url":"https://blog.toddaas.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.toddaas.com/ accesskey=h title="  (Alt + H)"></a><div class=logo-switches></div></div><ul id=menu><li><a href=https://blog.toddaas.com/ title=home><span>home</span></a></li><li><a href=https://blog.toddaas.com/posts/ title=posts><span>posts</span></a></li><li><a href=https://blog.toddaas.com/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 2</h1><div class=post-meta><span title='2024-04-04 05:10:21 +1000 +1000'>April 4, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Todd</div></header><div class=post-content><p>Overdue for Part 2 so thought I&rsquo;d include some of my learnings along the way&mldr;</p><h2 id=why-warm-pools-again>Why Warm Pools again?<a hidden class=anchor aria-hidden=true href=#why-warm-pools-again>#</a></h2><p>Taking a step back to networking for a brief second and Warm pools from <a href=https://blog.toddaas.com/posts/ec2_warm_pools_are_useful_part_1/>Part 1</a>. Warm Pools are very useful for scaling network appliances, for example, a set of firewall appliances in an Autoscaling Group behind a Gateway Load Balancer (GWLB). This is simply because notoriously network appliances often take a long time to boot getting all their bootstrapping and inspection, IPS/IDS jazz together. Therefore, by using Warm pools, a network appliance can be quickly placed in service in the Autoscaling Group, without the necessity of overprovisioning the Autoscaling Group with running instances incurring unnecessary costs. With that said, if you&rsquo;re using Warm pools alongside Lifecycle Hooks you need to take into account the additional overheads of automation to move instances from the Warm pool to the Autoscaling Group. This post covers the CDK Construct I wrote for Warm pools to extend the existing functionality of the default <a href=https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_autoscaling.WarmPool.html>CDK WarmPool class</a> to support this required automation for use with future Autoscaling Groups backed by Firewall appliances or EC2 instances using Lifecycle Hooks. CDK constructs allow you to abstract, reuse, repeat.</p><h2 id=cdk-constructs>CDK Constructs<a hidden class=anchor aria-hidden=true href=#cdk-constructs>#</a></h2><p>I&rsquo;ve been using the AWS Cloud Development Kit (CDK) for a few years now since version 1 (now version 2), predominantly for proof of concepts, testing AWS services, and as part of automating my troubleshooting workflow in replicating customer environments. Mainly the constructs I&rsquo;ve been using are the AWS service constructs. That said, as I&rsquo;ve gotten into using the CDK more and more, I&rsquo;ve found myself using other Construct libraries which speed up the implementation of existing best practice patterns <a href=https://docs.aws.amazon.com/solutions/latest/constructs/welcome.html>practice patterns</a> or just mashing together AWS service constructs with abstractions though Open Source constructs available via <a href=https://constructs.dev/>Construct Hub</a>. CDK&rsquo;s ability to share abstractions of cloud infrastructure underpinned by a modern programming language is what makes it great. AWS has also open-sourced the Construct Hub <a href=https://github.com/cdklabs/construct-hub>here</a> itself, for the use case of a private construct library within an organization to share reusable IaC constructs and patterns.</p><p>Now onto the CDK constructs, when it comes to the AWS service Level 2 (L2) constructs whilst they are supposed to operate at a higher level of abstraction, i.e., not require initialization of the same properties of a CFN resource. L2 constructs do not cater to all usage scenarios. This means that at times they often represent resources similar to the lowest level abstraction of Level (L1) constructs, basically the raw CFN resources and resource properties. This is where the composition over inheritance principle with CDK allows you to extend an existing CDK construct&rsquo;s functionality to include other constructs and cater to custom use cases. For example, in automating Autoscaling groups using Warm pools to move instances from the Warm pool into service automatically, something which the default L2 <a href=https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_autoscaling.WarmPool.html>CDK WarmPool class</a> does not do by default.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/pnFisVo40nk style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div><h2 id=projen>Projen<a hidden class=anchor aria-hidden=true href=#projen>#</a></h2><p>What I discovered along the way when wanting to share my construct with the CDK community, is that there is some barrier to entry (contribute) when it comes to meeting the requirements to have a CDK Construct in Construct Hub. To add, it was a manual process to release changes or updates to my construct whilst meeting these requirements and then push these changes to NPM, which are synced to Construct Hub. This is where a tool called Projen <a href=https://projen.io/>here</a> helped a lot. Projen does a lot of the heavy lifting required in terms of scaffolding a consumable CDK construct or any other supported project. This includes generating CI/CD pipelines based around Conventional Commits <a href=https://www.conventionalcommits.org/en/v1.0.0/>here</a> in the form of Github Actions workflows. For example, a release workflow for validating a CDK construct and releasing the construct to the NPM public repositories, conforming to Construct Hub <a href=https://constructs.dev/contribute>requirements</a>. Projen also has a workflow for keeping any code dependencies nicely updated automatically through PRs on the repository.</p><h2 id=my-warm-pool-cdk-construct>My Warm Pool CDK Construct<a hidden class=anchor aria-hidden=true href=#my-warm-pool-cdk-construct>#</a></h2><p>So how does my Warm pools construct work, what does it do? Essentially, the construct extends <a href=https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_autoscaling.WarmPool.html>CDK WarmPool class</a> with a Lambda function that&rsquo;s triggered through a CloudWatch EventBridge Rule when an instance moves out of a Warm Pool. EC2 Autoscaling, like most AWS services, publishes its events to CloudWatch EventBridge. As such, it&rsquo;s simple to create an EventBridge rule that filters for Warm Pool origin-related events based on the autoscaling group, then trigger the Lambda, calling complete-lifecycle-action and placing the instance in service.</p><p><a href=https://constructs.dev/packages/@pandanus-cloud/cdk-autoscaling-warmpool><img loading=lazy src="https://constructs.dev/badge?package=%40pandanus-cloud%2Fcdk-autoscaling-warmpool" alt="View on Construct Hub"></a></p><h2 id=a-cdk-app-example>A CDK App Example<a hidden class=anchor aria-hidden=true href=#a-cdk-app-example>#</a></h2><p>Here&rsquo;s a simple CDK app using the my Warm Pool Construct <a href=https://github.com/toddsfish/warmpools-test>https://github.com/toddsfish/warmpools-test</a>. You can also use this example CDK app if you just want to play around with the behavior of Autoscaling Warm Pools in general.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.toddaas.com/tags/aws/>Aws</a></li><li><a href=https://blog.toddaas.com/tags/automation/>Automation</a></li><li><a href=https://blog.toddaas.com/tags/ec2-autoscaling/>Ec2 Autoscaling</a></li><li><a href=https://blog.toddaas.com/tags/ec2/>Ec2</a></li><li><a href=https://blog.toddaas.com/tags/autoscaling/>Autoscaling</a></li><li><a href=https://blog.toddaas.com/tags/lambda-function/>Lambda Function</a></li><li><a href=https://blog.toddaas.com/tags/eventbridge/>Eventbridge</a></li><li><a href=https://blog.toddaas.com/tags/serverless/>Serverless</a></li><li><a href=https://blog.toddaas.com/tags/lambda/>Lambda</a></li><li><a href=https://blog.toddaas.com/tags/cdk/>Cdk</a></li><li><a href=https://blog.toddaas.com/tags/gateway-load-balancer/>Gateway Load Balancer</a></li><li><a href=https://blog.toddaas.com/tags/firewalls/>Firewalls</a></li><li><a href=https://blog.toddaas.com/tags/cloud-development-kit/>Cloud Development Kit</a></li><li><a href=https://blog.toddaas.com/tags/autoscaling-warm-pools/>Autoscaling Warm Pools</a></li><li><a href=https://blog.toddaas.com/tags/warmpools/>Warmpools</a></li><li><a href=https://blog.toddaas.com/tags/cdk-construct/>Cdk Construct</a></li><li><a href=https://blog.toddaas.com/tags/construct-hub/>Construct Hub</a></li></ul><nav class=paginav><a class=next href=https://blog.toddaas.com/posts/ec2_warm_pools_are_useful_part_1/><span class=title>Next »</span><br><span>EC2 Autoscaling Warm Pools are very useful for looooooooong bootstrap times - Part 1</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2024 <a href=https://blog.toddaas.com/>toddaas blog</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>